# 八数码问题
> A*算法

基本思想：定义一个评价函数，对当前的搜索状态进行评估，找出一个最有希望的节点进行扩展：f(n) = g(n) + h(n)，n为被评价节点
g*(n)：从s到n的最优路径的实际代价
h*(n)：从n到g的最优路径的实际代价
f*(n)=g*(n)+h*(n)：从s经过n到g的最优路径的实际代价
g(n)、h(n)、f(n)分别是g*(n)、h*(n)、f*(n)的估计值
g (n)通常为从S到到n这段路径的实际代价，则有g (n) ≥ g*(n)
h (n):是从节点n到目标节点Sg的最优路径的估计代价. 它的选择依赖于有关问题领域的启发信息，叫做启发函数
A算法：在图搜索的一般算法中，在搜索的每一步都利用估价函数f(n)=g(n)+h(n)对Open表中的节点进行排序表中的节点进行排序, 找出一个最有希望的节点作为下一次扩展的节点。
在A算法中，如果满足条件：h(n)≤h*(n)，则A算法称为A*算法。
在本算法中，为实现八数码的搜索问题，定义估价函数为：f(n)=g(n)+h(n)，
其中g（n）表示节点n在搜索树中的深度；
h（n）表示节点n的各个数码到目标位置的曼哈顿距离和

> 八数码问题

在3×3的方格上分别放置1，2，3，4，5，6，7，8，9的八张排，初始状态为S0，目标状态为Sg，计算出从S0到Sg的方法。

> 优点

在八数码问题上使用A*算法的优点在于相比盲目式搜索算法，启发式搜索算法更加智能，搜索路径更优，效率更好

> 遇到的问题

根据用户的输入有时候会出现栈溢出的情况（20代往后就会出现），现已解决，即用循环代替递归，可以避免栈溢出的情况，代码已更新到最新的。

> 提供的测试用例

test1
起始态 {2,8,3,1,6,4,7,0,5}
终态 {1,2,3,8,4,7,6,0,5}

test2
起始态{2,8,3,1,6,4,7,0,5}
终态{1,2,3,8,0,4,7,6,5}

